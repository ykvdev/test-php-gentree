Написать программу gentree используя PHP7.1, генерирующую JSON файл на основе входящего CSV файла.

Программа принимает в качестве параметров командной строки:
1) Путь к входящему файлу в формате CSV (input.csv)
2) Путь для выгружаемого файла (output.json)

Описание:
1) Файл input.csv - это пример файла который будет передан в программу. 
В нем находится дерево в табличном представлении. 
Связь ребенок-родитель между элементами осуществляется через колонки Item Name и Parent.
Колонка Item Name содержит уникальные имена элементов. 
Дерево имеет 3 типа элементов (см. колонку Type): 'Изделия и компоненты','Варианты комплектации','Прямые компоненты'.
2) Каждый элемент типа 'Прямые компоненты' имеет возможное продолжение через связь с элементом типа 
'Изделия и компоненты', эта связь указана в колонке 'Relation'. Необходимо построить продолжение дерева, присоединив к каждому элементу типа 'Прямые компоненты' ветку элемента типа 'Изделия и компоненты' используя эту связь.
В результате должно получится дерево представленное в прикрепленном к заданию output.json, которое необходимо сохранить на диск.
3) Тип элементов 'Варианты комплектации' не используется в генерации веток через колонку 'Relation', для них значение колонки Relation всегда пустое, но они присутствуют как элементы дерева при генерации связей через 'Прямые компоненты' и 'Изделия и компоненты' (пункт 2), далее в примере и в прикрепленном файле output.json можно это увидеть.

Рассмотрим небольшой кейс на примере самого первого элемента типа 'Прямые компоненты', видим вот такую исходную ветку:

- Total
    - ПВЛ
        - Стандарт.#1
            - Тележка Б25.#2
            
Элемент 'Тележка Б25.#2' имеет тип 'Прямые компоненты' и согласно колонке 'Relation' имеет связь с элементом 'Тележка Б25' типа 'Изделия и компоненты'
Значит необходимо к элементу 'Тележка Б25.#2' присоединить дерево которое входит в элемент 'Тележка Б25', получаем:

- Total
    - ПВЛ
        - Стандарт.#1
            - Тележка Б25.#2
                - Стандарт.#5
                    - РБ ЦДЛР.9855.00.02.000.#17
                    - БН ЦДЛР.9855.00.01.000.#18
                    - Колесная пара 25 т.#19
                ... <- мы опустили дальше элементы для уменьшения кейса с примером
                
Получив такое дерево, мы должны продолжить его генерацию дальше, так элемент 'РБ ЦДЛР.9855.00.02.000.#17' имеет связь с элементом 'РБ ЦДЛР.9855.00.02.000' через колонку 'Relation', а элемент 'БН ЦДЛР.9855.00.01.000.#18' с 'БН ЦДЛР.9855.00.01.000' и элемент 'Колесная пара 25 т.#19' с 'Колесная пара 25 т'
Достраиваем ветки и получаем:

- Total
    - ПВЛ
        - Стандарт.#1
            - Тележка Б25.#2
                - Стандарт.#5
                    - РБ ЦДЛР.9855.00.02.000.#17
                    - БН ЦДЛР.9855.00.01.000.#18
                    - Колесная пара 25 т.#19
                        - Стандарт.#10
                            - Колесо 25т.#52
                            - Ось 25т.#53
                ... 
                            
Далее пробуем подцепить к 'Колесо 25т.#52' и 'Ось 25т.#53' продолжение как ранее мы сделали с 'Колесная пара 25 т.#19', но из-за отсутствия веток в 'Колесо 25т' и 'Ось 25т' мы останавливаемся и переходим к другим элементам продолжая генерацию дерева пока не достигнем для каждой ветки дерева конца из-за отсутствия вложенности у элементов типа 'Изделия и компоненты'

Пример полной генерации смотри в файле output.json который прикреплен к заданию

Дополнения:
- Входящий CSV файл в кодировке UTF-8, разделитель точка с запятой, экранирование двойными кавычками
- Алгоритм должен быть универсален и учитывать любое кол-во входящих строк, но максимально ожидаемый объем входящего файла можно ограничить проверкой на 20 тыс строк
- Колонки входящего файла строго фиксированы, файл всегда имеет 4 колонки вида и порядка представленном в input.csv
- Входящие данные гарантируют отсутствие бесконечных рекурсий
- Исходящий JSON файл в кодировке UTF-8

Решение представить в виде архива с исходным кодом, либо в виде ссылки на онлайн Git-репозиторий
Код должен собираться и запускаться под Ubuntu/Debian, а так же иметь README по сборке и запуску.

Критерии оценки решения:
1) Качество архитектуры приложения и читабельность кода, легкость дальнейшего развития и поддержки, уровень абстрактности кода, уровень модульности, качество применения ООП. (Решения в виде портянки кода в одном файле не будут рассматриваться)
2) Правильность выдаваемых результатов и наличие тестов
3) Скорость работы и потребление памяти